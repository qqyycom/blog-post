---
layout: post
title:  "MySQL事务"
date:   2020-04-28 12:34:25 +0800
categories: 数据库 MySQL
tags: 数据库 MySQL
subtitle: "MySQL事务"
toc: true
---

## 什么是事务

在RDBMS中, 事务是访问和更新数据库的程序执行单元, 由有限个操作序列构成

## 事务有什么特性

事务有4个重要特性 ACID Atomicity, Consistency, Isolation, Durability

1. A(Atomicity) 原子性: 事务中的操作是一个整体, 从结果看只有成功和失败, 成功则提交, 失败则回滚
2. C(Consistency) 一致性: 数据在事务开始前和结束后, 数据保持了一致性. 例如, 一个转账事务, 一致性保证了A, B账户的总金额在事务前后是一致的.
3. I(Isolation) 隔离性: 事务中的一些中间状态对其他事务是不可见的. 
4. D(Durability) 持久性: 事务执行成功后, 持久性保证数据的改变会被保存下来, 不会因为任何外部原因(如系统错误)导致数据改变失效



## MySQL中如何实现事务

数据库的实现, 很少有满足能同时满足ACID的实现, MySQL INNODB默认的隔离等级为 *可重复读* , 不满足隔离性,  本文主要介绍`隔离性`的相关实现



### 数据库并发操作可能导致的数据不一致问题

 数据库并发操作时, 如果没有有效的机制, 可能会导致种种问题

问题1. 脏读

> 指一个事务读取了另外一个事务未提交的数据。

问题2. 不可重复读

> 指在一个事务内读取表中的某一行数据，多次读取结果不同。 不可重复读和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。

问题3. 幻读

> 指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。(幻读只跟`Insert`有关)

### 事务的隔离等级

定义了不同的隔离等级, 来组合上述问题

1. Read Uncommitted (读未提交) 

   > 隔离级别最低的一种事务级别。在这种隔离级别下，会引发脏读、不可重复读和幻读。

2. Read Committed(读已提交)

   > 读到的都是别人提交后的值。这种隔离级别下，会引发不可重复读和幻读，但避免了脏读。

3. Repeatable Reads(可重复读)

   > 这种隔离级别下，会引发幻读，但避免了脏读、不可重复读。(注: INNODB在RR级别下解决幻读问题)

4. Serializable(串行化)

   > 是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行。脏读、不可重复读、幻读都不会出现。

   

   ```
   create table T(c int) engine=InnoDB;   // 简单建表
   insert into T(c) values(1);
   ```

   

   | 事务A      | 事务B    |
   | ---------- | :------- |
   | BEGIN;     |          |
   |            | BEGIN;   |
   | 查询得到1  |          |
   |            | 将1改为2 |
   | 查询得到V1 |          |
   |            | COMMIT;  |
   | 查询得到V2 |          |
   | COMMIT;    |          |
   | 查询得到V3 |          |

   - 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
   - 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
   - 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
   - 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。



### INNODB中如何实现这几种隔离级别的

#### 基于锁实现的串行模型

1. 共享锁与排它锁

   - **排它锁（exclusive lock）** 又称X锁，这是最好理解的锁，在一般的并发编程中，我们为资源加上的一般都是排它锁，要获取锁，必须是资源处于未被加锁状态，如果有人已经为资源加锁，则需要等待锁释放才能获取锁，这种锁能够保证并发时也能够串行处理某个资源，实现排队的目的。MySQL中使用`for update`加排它锁,  **获取记录的排它锁（X锁），则允许这个事务更新它**

   - **共享锁（share lock）** 又称S锁，这是比排它锁更加宽松的锁，当一个资源没有被加锁或者当前加锁为共享锁时，可以为它加上共享锁，也就是一个资源可以同时被加无限个共享锁。此时由于资源已经被加锁，虽然可以继续加共享锁，但是不能加排它锁，需要等待资源的锁被完全释放才能获取排它锁。共享锁的目的是为了提高非冲突操作的并发数，同时能够保证冲突操作的排队执行。MySQL中使用` lock in share mode`加共享锁, **获取记录的共享锁（S锁），则仅允许事务读取它**

2. 严格两阶段加锁

   两阶段加锁是为了保证: 一个记录被某个事务读取或者写入，则直到这个事务提交，才能被别的事务修改

   **两阶段加锁(2PL)它规定事务的加锁与解锁分为2个独立阶段，加锁阶段只能加锁不能解锁，一旦开始解锁，则进入解锁阶段，不能再加锁**。 **严格两阶段加锁（S2PL）在2PL的基础上规定事务的解锁阶段只能是执行commit或者rollback后**

#### 如何通过加锁解决并发会出现的问题

1. 脏写(写覆盖): 事务写记录加X锁
2. 脏读: 事务写记录加X锁
3. 不可重复读: 事务读记录加锁(X或S)
4. 幻读: GAP LOCK
5. 读偏差(read skew) : 读数据必须获取锁，写数据必须加排它锁
6. 写偏差(write skew) : 读数据必须获取锁，写数据必须加排它锁
7. 丢失更新 : 读数据必须获取锁，写数据必须加排它锁

> 读偏差, 写偏差, 丢失更新本质上都是因为读到的数据更新了

### 如何通过引入版本控制, 优化锁冲突

INNODB 通过MVCC创建快照版本数据, 不同的事务操作不同版本的数据, 增加并发性

#### MVCC如何创建快照

##### 版本链(undo log)

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。

在InnoDB中每条记录中都有2个隐藏列，1个是trx_id，一个是roll_pointer

- 而每条记录也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给trx_id, 把roll_pointer赋值为上一份数据版本的地址

##### Read View

事务执行第一条语句时生成的数据结构. Read View保存一下信息:

| fields         | comment                                           |
| -------------- | ------------------------------------------------- |
| m_ids          | 当前Read View生成时, 系统中没有提交的事务Id集合   |
| min_trx_id     | 当前Read View生成时, 系统中正在进行的事务的最小Id |
| max_trx_id     | 生成Read View时, 系统应该分配的下一个事务ID的值   |
| creator_trx_id | 当前事务Id                                        |

> Read View是事务执行语句时才会生成的，仅仅执行start transaction是不会生成Read View的

##### MVCC中的快照实现

版本链 + ReadView

当事务读取到某条记录时, 会根据Read View中的信息判断此记录的哪个版本是这个事务可见的：

1. 如果`数据版本中的trx_id`和ReadView中的`creator_trx_id`相同: 表示数据的更改由当前事务完成, 则可读
2. 如果`数据版本中的trx_id < min_trx_id`, 表示此版本由之前已提交的事务写入, 则可读
3. 如果`数据版本中的trx_id >= max_trx_id`, 表示此数据版本由之后的事务写入, 一定不可读
4. 如果` min_trx_id < 数据版本中的trx_id < max_trx_id`, 且 `trx_id IN m_ids`, 表示此版本的数据在当前事务开始时还未提交, 不可读, 否则可读

##### 读提交(RC)级别实现

RC级别主要解决了脏读问题, 每次执行一条SQL重新获取一致性视图

##### 可重复读(RR)级别实现

RR级别主要解决了可重复读的问题, 事务开始时创建视图, 并一直沿用该视图 (INNODB中也解决了幻读问题)

> 注: 事务开始指的不是begin / start transaction, 而是执行的第一个操作



#### MVCC的局限性

如上所属, MVCC是为了代替读锁, 这样, 写入时, 就不需要等待读锁释放, 提高了并发. 但是也有些问题无法解决

##### 1. 无法避免幻读

- `幻读`存在于`当前读` , `快照读`下是没有幻读问题的

- MySQL RR下如何解决

  `GAP LOCK` : 幻读是因为MVCC无法记录在Read View基础上新插入的数据, 所以, `INNODB`采用了**GAP LOCK**的方式锁住了qita查询记录间的`间隙` , 如果事务要插入记录，需要获取**插入意向锁（Insert Intention Lock）**,如果需要插入的间隙有间隙锁，则获取插入意向锁会失败必须进行锁等待.

##### 2. 无法避免 读偏差 和 写偏差

​	由于MVCC中读-写互不阻塞，因此事务读取的快照可能已经过期，读到的可能已经成为陈旧数据

##### 3. 无法避免 丢失更新

​	MVCC并不能防止丢失更新，需要配合其他机制。

#### INNODB中隔离性的实现

综上所述: INNODB实现`快照读(Snapshot Read)`基于多版本并发控制(MVCC) ,  使用Read view代替读锁, 用于支持`RC`和`RR`级别的隔离. 

实现`当前读(Currently Read)`基于共享锁和排它锁

“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。